---
title: Multi-Stream 관련 연구 사례
description: Multi-Stream 및 동시적 처리(Simultaneous Processing) 아키텍처 관련 주요 연구들을 심층 분석합니다.
---

이 문서는 Multi-Stream 아키텍처와 관련된 주요 연구들을 논문 단위로, 각각 개요, 아키텍처, 벤치마크, 학습 방식으로 나누어 상세히 분석합니다.

## 1. Shanks: Simultaneous Hearing and Thinking for Spoken Language Models

- **논문:** "Shanks: Simultaneous Hearing and Thinking for Spoken Language Models" (arXiv 2024)
- **핵심 의의:** 사용자가 말하는 동안 모델이 동시에 "내면의 추론(unspoken reasoning)"을 생성하는 범용 추론 프레임워크를 제안했습니다. 이는 기존 모델들이 사용자의 발화가 끝난 후에야 처리를 시작하여 응답 지연이 발생하는 한계를 극복하고, 실시간 상호작용을 구현하기 위한 중요한 접근 방식입니다.

### 1.1. 개요 (Overview)

Shanks는 스트리밍되는 음성 입력을 고정된 길이의 청크(chunk) 단위로 처리합니다. 각 음성 청크를 받을 때마다, 이전에 입력된 모든 음성과 내부 추론을 바탕으로 새로운 "사고(thinking)" 청크를 생성합니다. 이 내부적인 사고 과정을 통해 모델은 사용자의 말을 끊고 개입할지(interrupt) 또는 API 같은 도구를 호출할지 등을 사용자가 아직 말하는 도중에 결정할 수 있습니다. 이 프레임워크는 End-to-End SLM과 Cascade SLM(ASR+LLM) 두 가지 방식 모두에 적용 가능하도록 설계되었습니다.

### 1.2. 아키텍처 (Architecture)

Shanks는 사용자 음성을 고정된 시간 단위의 청크(S₁, S₂, ...)로 분할하여 처리합니다. i번째 음성 청크(Sᵢ)를 입력받으면, 이를 바탕으로 i번째 사고 청크(Rᵢ)를 생성합니다. 즉, 사용자가 (i+1)번째 음성 청크를 말하는 동안, 모델은 i번째 사고 청크를 내부적으로 생성하며 '듣는 것'과 '생각하는 것'을 동시에 수행합니다.

이 과정에서 생성된 사고 청크(Rᵢ)는 발화되지 않으며, 모델의 내부적인 추론으로만 사용됩니다. 이 아키텍처는 두 가지 주요 형태로 구현되었습니다.

1.  **Shanks-E2E:**
    -   End-to-End Spoken Language Model(논문에서는 Qwen-2.5-Omni 사용)을 파인튜닝하여 '들으면서 생각하는' 능력을 학습시킵니다.
    -   모델은 발화되지 않는 내부 추론을 `<think>`와 `</think>` 토큰으로 감싸도록 학습되며, 실제 응답 토큰만 음성 합성(TTS) 엔진으로 전달됩니다.

2.  **Shanks-Cascade:**
    -   ASR 모델(Whisper-large-v3)과 강력한 텍스트 기반 LLM(Qwen-2.5-7B-Instruct)을 계단식으로 연결합니다.
    -   ASR이 생성한 부분적인 텍스트(partial transcription)를 LLM에 전달하여 사고 청크를 생성하게 함으로써, 더 강력한 추론 능력을 활용하는 방안을 탐구합니다.

### 1.3. 벤치마크 (Benchmarks)

Shanks의 성능은 두 가지 시나리오에서 평가되었습니다.

1.  **사용자 발화 중단 (수학 문제 풀이):**
    -   **과제:** 사용자가 수학 문제를 설명하고 풀이 과정을 말할 때, 모델이 듣다가 오류를 발견하면 즉시 사용자의 말을 중단시키는 능력 평가.
    -   **결과:** Shanks-E2E 모델은 '생각 없는' 베이스라인 모델보다 37.1% 더 정확하게 오류를 찾아 중단시켰습니다. 특히 Shanks-Cascade 모델은 78.3%의 유효한 중단률을 보여 가장 뛰어난 성능을 기록했으며, 평균 5.08초의 중단 지연 시간을 보였습니다.

2.  **청취 중 도구 사용 (목적 지향 대화):**
    -   **과제:** 여행사 에이전트 역할을 하는 모델이 사용자의 항공편, 렌터카 예약 요청을 듣는 중에 필요한 API를 호출하는 능력 평가.
    -   **결과:** Shanks는 전체 API 호출의 56.9%를 사용자가 말을 마_치기 전에_ 성공적으로 수행했습니다. 이를 통해 사용자의 발화가 끝난 후 응답까지 걸리는 시간을 크게 단축했습니다. 하지만 최종 응답의 성공률 및 품질은 '듣고 나서 호출하는' 베이스라인 모델이 더 높았으며, 두 방식을 결합했을 때 가장 좋은 성능을 보였습니다.

### 1.4. 학습 (Training)

Shanks는 표준 언어 모델링 손실 함수(cross-entropy loss)를 사용하여 학습됩니다. 학습 데이터는 전체 사용자 발화를 청크 {S₁, ..., Sɴ}로 나누고, 이에 해당하는 사고 청크 {R₁, ..., Rɴ}와 최종 응답 O를 쌍으로 구성하여 만들어집니다. 모델은 S₁이 주어졌을 때 R₁을, {S₁, R₁, S₂}가 주어졌을 때 R₂를 예측하는 식으로 순차적으로 학습됩니다.

-   **중단(Interruption) 데이터:** 사용자가 정답을 말하는 경우(중단 안 함)와 오답을 말하는 경우(첫 오류에서 중단함)의 데이터를 구성합니다. GPT-4o를 사용하여 각 상황에 맞는 사고 청크(Rᵢ)와 `[INTERRUPT]` 토큰 삽입 위치를 생성합니다.
-   **도구 호출(Tool Call) 데이터:** ComplexFuncBench 데이터셋을 기반으로, GPT-4o를 이용해 사용자의 발화 중 API 호출이 가능한 가장 빠른 시점을 찾아냅니다. 이 정보를 바탕으로 특정 사고 청크(Rᵢ) 내에 API 호출 구문을 포함시켜 학습 데이터를 구성합니다. API 호출에 대한 응답 부분은 학습 시 손실 계산에서 제외(masking)됩니다.

---

## 2. Language Model Can Listen While Speaking

- **논문:** "Language Model Can Listen While Speaking" (arXiv 2024)
- **핵심 의의:** 실시간 양방향 상호작용을 위해 '말하면서 동시에 듣는' 능력을 갖춘 End-to-End 모델(LSLM: Listening-while-Speaking Language Model)을 제안했습니다. 이 모델은 기존의 턴(turn) 기반 대화 모델의 한계를 넘어, 완전한 양방향 통신(Full Duplex Modeling)을 구현하여 실시간 중단(interruption)을 가능하게 합니다.

### 2.1. 개요 (Overview)

LSLM은 대화형 음성 언어 모델(iSLM)에서 완전한 양방향 통신을 구현하는 것을 목표로 합니다. 이를 위해 모델은 자신이 말하는(speaking) 채널과 사용자의 입력을 듣는(listening) 채널을 동시에 통합합니다. 토큰 기반의 TTS(Text-to-Speech)를 통해 음성을 생성함과 동시에, 스트리밍 SSL(Self-Supervised Learning) 인코더로 실시간 음성 입력을 처리합니다. 사용자의 중단이 감지되면, `[IRQ]`라는 특수 토큰을 통해 자신의 발화를 즉시 멈출 수 있습니다.

### 2.2. 아키텍처 (Architecture)

LSLM 아키텍처는 크게 세 가지 능력으로 구성됩니다.

1.  **말하기 능력 (Speaking Ability):**
    -   실시간 성능을 위해 단일 레이어의 이산 오디오 토큰(discrete audio tokens)을 사용하는 자기회귀(autoregressive) 방식의 토큰 기반 TTS 모델을 사용합니다.
    -   `vq-wav2vec` SSL 인코더가 음성을 연속적인 임베딩으로 변환하고, 이를 양자화하여 이산 토큰을 생성합니다. 최종적으로 GAN 기반의 보코더(vocoder)가 이 토큰들로부터 음성 신호를 재구성합니다.

2.  **듣기 능력 (Listening Ability):**
    -   말하기 능력과 동일한 스트리밍 SSL 인코더를 사용하여 들어오는 오디오를 실시간으로 처리합니다. 여기서 생성된 연속적인 임베딩은 프로젝션 모듈을 통해 자기회귀 모델에 적합한 형태로 변환됩니다.

3.  **양방향 통신 능력 (Full Duplex Modeling Ability):**
    -   모델은 다음 토큰을 예측하기 위해 **말하기 채널**(이전 단계에서 생성된 이산 토큰들)과 **듣기 채널**(실시간으로 처리된 음성 임베딩)의 정보를 융합(fusion)합니다.
    -   세 가지 융합 전략(초기, 중간, 후기)을 실험했으며, 각 트랜스포머 블록에서 정보를 결합하는 **중간 융합(Middle Fusion)** 방식이 가장 효과적이었습니다.

### 2.3. 벤치마크 (Benchmarks)

LSLM은 두 가지 양방향 통신(FDM) 환경에서 평가되었습니다.

1.  **명령어 기반 FDM:** 특정 키워드('interrupt' 등)으로 중단이 발생하는 시나리오.
2.  **음성 기반 FDM:** 처음 보는 화자의 다양한 단어로 중단이 발생하는, 더 현실적인 시나리오.

-   **평가 지표:**
    -   **TTS 성능:** Whisper large v3 모델을 이용한 단어 오류율(WER) 측정.
    -   **상호작용 성능:** 중단 발생 후 1초 내에 모델이 발화를 멈추는 능력을 기반으로 Precision, Recall, F1 점수 측정.

-   **실험 결과:**
    -   **명령어 기반 환경:** 중간 융합(Middle Fusion) 전략을 사용한 LSLM-MF 모델이 가장 좋은 성능을 보였으며, 깨끗한 환경에서 4.05%, 노이즈 환경에서 4.51%의 낮은 WER을 달성했습니다.
    -   **음성 기반 환경:** 더 어려운 이 환경에서는 WER이 5.33%(clean), 8.50%(noisy)로 증가했으며, 상호작용 F1 점수도 85.15%(noisy)로 다소 감소했습니다. 이는 실제 환경의 복잡성을 보여줍니다.

### 2.4. 학습 (Training)

모델은 TTS, 중단, 노이즈 데이터를 사용하여 20 에포크 동안 학습되었습니다. 학습 데이터에는 50% 확률로 노이즈와 중단 상황이 무작위로 추가됩니다. 중단 음성이 포함된 경우, 해당 음성 시작 0.5초 후에 `[IRQ]` 토큰이 트리거되어 추가적인 음성 생성을 멈추도록 학습합니다.

-   **옵티마이저:** AdamW (learning rate 5e-4, no weight decay)
-   **학습률 스케줄:** 5,000 스텝 동안 웜업(warm-up) 후 코사인 감쇠(cosine decay) 적용.

Ablation study를 통해, TTS 백본과 스트리밍 SSL 인코더를 함께 계속 학습시키는 것이 전반적인 성능에 가장 좋다는 것을 확인했습니다. 이는 다양한 노이즈 환경에 대응하기 위해 SSL 인코더를 파인튜닝하는 것이 중요함을 시사합니다.

---

## 3. PersonaPlex: Voice and Role Control for Full Duplex Conversational Speech Models

- **논문:** "PersonaPlex: Voice and Role Control for Full Duplex Conversational Speech Models" (NVIDIA Research 2026)
- **핵심 의의:** 텍스트 프롬프트로 역할을 자유롭게 정의하고 다양한 음성으로 자연스러운 양방향 대화를 가능하게 하는 대화형 AI 시스템을 제안했습니다. 기존의 단계적(cascaded) 시스템이나 완전 양방향(full-duplex) 모델의 한계를 넘어, 사용자가 원하는 페르소나와 목소리로 실시간 끼어들기, 추임새 등 자연스러운 대화 리듬을 유지하는 상호작용을 구현했습니다.

### 3.1. 개요 (Overview)

NVIDIA의 PersonaPlex는 사용자가 텍스트 프롬프트로 역할을 정의하고, 다양한 목소리 중 하나를 선택하여 자연스러운 양방향 대화를 나눌 수 있게 하는 것을 목표로 합니다. 이 시스템은 '동시에 듣고 말하는' 이중 스트림(dual-stream) 구성을 통해, 사용자의 끼어들기(interruption), 추임새(backchannels)와 같은 자연스러운 대화의 동적인 요소를 처리하면서도, 주어진 역할과 목소리 톤을 일관되게 유지합니다.

### 3.2. 아키텍처 (Architecture)

PersonaPlex는 '하이브리드 프롬프팅(hybrid prompting)' 아키텍처를 사용합니다. 이는 목소리 톤과 특성을 제어하는 **음성 프롬프트(voice prompt, 오디오 임베딩)**와 역할 및 맥락을 정의하는 **텍스트 프롬프트(text prompt)**를 함께 사용하는 방식입니다.

- **기반 모델:** 70억 파라미터의 **Moshi** 아키텍처를 기반으로 합니다.
- **주요 구성 요소:**
    - **Mimi speech encoder/decoder:** 음성 인코딩 및 디코딩 담당.
    - **Temporal and depth transformers:** 시간적 정보 처리.
    - **Helium language model:** 의미론적 이해 및 언어 모델링 담당.

이러한 이중 스트림 구성은 시스템이 사용자의 말을 들으면서 동시에 자신의 응답을 생성하는 것을 가능하게 하여, 자연스러운 양방향 대화를 구현하는 핵심 요소로 작용합니다.

### 3.3. 벤치마크 (Benchmarks)

PersonaPlex의 성능은 자체적으로 구축한 두 가지 벤치마크를 통해 평가되었습니다.

1.  **FullDuplexBench:**
    -   **평가 항목:** 턴테이킹(turn-taking), 사용자 끼어들기, 정지(pause) 처리 등 **대화의 동적인 측면**과 GPT-4o가 판단하는 **응답의 질**을 평가합니다.
    -   **결과:** PersonaPlex는 다른 시스템들과 비교하여 대화 역학, 지연 시간, 과제 준수 측면에서 우수한 성능을 보였습니다.

2.  **ServiceDuplexBench:**
    -   **평가 항목:** 고객 서비스 시나리오에서 주어진 과제를 얼마나 잘 준수하는지를 평가합니다.

### 3.4. 학습 (Training)

자연스러운 대화형 음성 데이터의 부족 문제를 해결하기 위해, **실제 대화 데이터와 합성 데이터를 혼합**하는 방식을 사용했습니다.

-   **실제 데이터 가공:**
    -   스크립트 없이 진행된 실제 인간 대화 데이터(Fisher English corpus)를 사용합니다.
    -   LLM을 이용해 이 대화들에 대한 맥락 및 페르소나 설명(descriptor)을 생성하여, 페르소나 감독(persona-supervised) 데이터를 구축합니다.

-   **합성 데이터 생성:**
    -   언어 모델이 대화 스크립트와 페르소나 프롬프트를 생성합니다.
    -   NVIDIA의 Chatterbox TTS 기술을 사용하여 이 스크립트를 음성으로 합성합니다.

모델은 이렇게 혼합된 데이터셋으로 학습함으로써, 자연스러운 상호작용 패턴과 주어진 과제를 따르는 능력을 동시에 학습하게 됩니다.

---

## 4. Front-Loading Reasoning: The Synergy between Pretraining and Post-Training Data

- **논문:** "Front-Loading Reasoning: The Synergy between Pretraining and Post-Training Data" (NVIDIA Research, arXiv 2025)
- **핵심 의의:** LLM의 추론 능력을 가르치는 최적의 전략을 탐구한 연구입니다. 기존처럼 후-학습(post-training) 단계에서 추론을 주입하는 것보다, **사전-학습(pre-training) 단계에 추론 데이터를 통합("Front-Loading")하는 것**이 훨씬 효과적이고 강력한 기반을 형성한다는 것을 실험적으로 증명했습니다.

### 4.1. 개요 (Overview)

이 연구는 LLM에 추론 능력을 언제, 어떻게 가르치는 것이 가장 효과적인지에 대한 체계적인 실험을 진행했습니다. 결론적으로, 사전-학습 단계에서 추론 데이터를 미리 학습시키는 "Front-Loading" 접근법이 모델의 근본적인 능력을 크게 향상시킨다는 것을 발견했습니다. 이렇게 형성된 능력은, 나중에 후-학습(fine-tuning) 단계에서 더 많은 데이터를 사용하더라도 완전히 따라잡을 수 없는 깊은 효과를 가집니다. 또한 이 연구는 "비대칭 데이터 원칙"을 제시했는데, 사전-학습은 **다양한 패턴의 데이터**에서 더 큰 이점을 얻고, 지도 미세조정(SFT) 단계는 **고품질 데이터**에 더 민감하게 반응한다는 것입니다.

### 4.2. 아키텍처 (Architecture)

이 연구는 새로운 아키텍처를 제안하기보다는, 특정 학습 전략의 효과를 검증하기 위한 실험 환경을 구축했습니다.

-   **기본 모델:** 80억(8B) 파라미터 규모의 LLM을 기반으로 실험을 진행했습니다.
-   **학습 데이터:** 총 1조(1 Trillion) 개의 토큰을 사용하여 모델을 학습시켰으며, 일반적인 데이터(general corpus)와 다양한 규모, 다양성, 품질을 가진 추론 데이터를 혼합하여 사용했습니다.

### 4.3. 벤치마크 (Benchmarks)

모델의 성능은 사전-학습, 지도 미세조정(SFT), 강화학습(RL)의 각 단계가 끝날 때마다 측정되었습니다.

-   **평가 분야:** 수학, 과학, 코딩 등 전문가 수준의 추론 능력을 요구하는 다양한 벤치마크에서 평가가 이루어졌습니다.
-   **주요 결과:**
    -   사전-학습에 추론 데이터를 포함시킨 모델은 그렇지 않은 모델에 비해 전문가 수준의 작업에서 **최대 19%의 성능 향상**을 보였습니다.
    -   사전-학습 단계에서 얻은 성능 향상은 SFT와 RL 단계를 거치며 더욱 증폭되었습니다.
    -   사전-학습 데이터의 '다양성'을 높였을 때 평균 11%의 성능 향상을, SFT 데이터의 '품질'을 높였을 때 평균 15%의 성능 향상을 확인하여 "비대칭 원칙"을 증명했습니다.

### 4.4. 학습 (Training)

이 연구의 핵심은 "Front-Loading"이라는 학습 전략과 "비대칭 데이터 전략"입니다.

1.  **Front-Loading Reasoning:**
    -   모델 학습의 가장 초기 단계인 사전-학습 과정에 대규모 추론 데이터를 혼합하여, 모델이 초반부터 추론 패턴의 기초를 학습하도록 유도합니다.

2.  **비대칭 데이터 전략 (Asymmetric Data Strategy):**
    -   **사전-학습 (Pre-training):** 데이터의 '품질'보다는 '다양성'을 우선시합니다. 다양한 종류와 형태의 추론 과정을 모델에 노출시켜 일반화된 추론 능력을 기릅니다.
    -   **지도 미세조정 (Supervised Fine-Tuning, SFT):** 데이터의 '양'이나 '다양성'보다는 소량의 '고품질' 데이터를 사용하는 것이 더 효과적입니다. 이 단계에서 무분별하게 데이터 양을 늘리는 것은 오히려 성능에 해가 될 수 있음을 보여주었습니다.

이러한 전략은 사전-학습 단계에서 고품질 데이터가 가졌던 잠재적 효과가 SFT 단계 이후에 활성화된다는 점을 시사합니다.

---

## 5. Multi-Token Attention

- **논문:** "Multi-Token Attention" (arXiv 2025)
- **핵심 의의:** 기존 어텐션 메커니즘이 단일 토큰 벡터에만 의존하는 병목 현상을 해결하기 위해 **Multi-Token Attention (MTA)**을 제안했습니다. 이 새로운 어텐션은 컨볼루션(convolution) 연산을 통해 여러 쿼리(query) 및 키(key) 벡터를 동시에 고려하여 어텐션 가중치를 결정함으로써, 모델이 더 풍부하고 미묘한 컨텍스트 정보를 활용하여 관련 정보를 더 정확하게 찾을 수 있도록 합니다.

### 5.1. 개요 (Overview)

표준 어텐션 메커니즘은 하나의 쿼리 벡터와 키 벡터 사이의 유사도를 기반으로 어텐션 가중치를 계산합니다. 이는 관련 컨텍스트를 식별하는 데 사용되는 정보의 양을 제한하는 병목이 될 수 있습니다. Multi-Token Attention (MTA)은 쿼리, 키, 그리고 어텐션 헤드에 걸쳐 컨볼루션 연산을 적용하여 이 문제를 해결합니다. 이 방식을 통해, 인접한 쿼리와 키들이 서로의 어텐션 가중치에 영향을 줄 수 있게 되어, 단일 벡터의 용량을 초과하는 풍부한 정보를 활용하여 더 정밀한 어텐션을 가능하게 합니다.

### 5.2. 아키텍처 (Architecture)

MTA는 표준 멀티-헤드 어텐션(Multi-Head Attention)을 기반으로 세 가지 주요 구성 요소를 통합합니다.

1.  **키-쿼리 컨볼루션 (Key-query convolution):**
    -   어텐션 로짓(logits, softmax 이전) 또는 어텐션 가중치(weights, softmax 이후)에 대해 키와 쿼리의 시퀀스 길이를 축으로 2D 컨볼루션을 적용합니다. 이를 통해 여러 쿼리 및 키 토큰의 정보를 조합할 수 있습니다.

2.  **헤드 믹싱 컨볼루션 (Head mixing convolution):**
    -   어텐션 헤드 그룹에 걸쳐 컨볼루션 연산을 적용하여, 여러 헤드에서 계산된 어텐션 가중치를 서로 혼합합니다.

3.  **그룹 정규화 및 게이팅 (Group normalization with gating):**
    -   컨볼루션 연산 후에 적용되며, 그래디언트 흐름을 개선하고 모델이 동적으로 헤드를 활성화/비활성화할 수 있도록 돕는 시그모이드 게이팅 메커니즘을 포함합니다.

이 요소들은 다양하게 조합될 수 있으며, 예를 들어 키-쿼리 컨볼루션과 헤드 믹싱을 모두 3D 컨볼루션으로 한 번에 구현할 수도 있습니다.

### 5.3. 벤치마크 (Benchmarks)

MTA는 다양한 과제에서 표준 트랜스포머 아키텍처 대비 뛰어난 성능을 입증했습니다.

-   **언어 모델링:** 8.8억(880M) 파라미터 모델을 1050억(105B) 토큰으로 사전학습한 결과, MTA는 표준 트랜스포머 및 다른 변형 모델들보다 일관되게 낮은 Perplexity(혼잡도)를 달성했습니다.
-   **표준 벤치마크 (Zero-shot):** 대부분의 제로샷 벤치마크에서 MTA는 베이스라인 모델들보다 높은 평균 점수(44.9)를 기록했습니다.
-   **장문 컨텍스트 (Long Context):** 컨텍스트 길이를 4096으로 늘려 파인튜닝한 후에도 MTA는 Perplexity 및 **Needle-In-A-Haystack** (긴 문서에서 정보 찾기) 과제에서 월등한 성능을 보였습니다.
-   **장거리 의존성 과제:** **Lambada** (문맥 기반 단어 예측), **BabiLong** (장문 질의응답) 등에서 MTA 모델은 베이스라인을 능가하는 성능을 보였습니다.

### 5.4. 학습 (Training)

-   **사전학습:** 8.8억 파라미터 모델을 SlimPajama 데이터셋의 1050억 토큰으로 사전학습했습니다.
-   **컨볼루션 적용:** 학습 효율성을 위해, 키-쿼리 컨볼루션은 4개의 레이어마다, 헤드 컨볼루션은 모든 레이어에 적용했습니다.
-   **커널 초기화:** 커널을 0이나 상수가 아닌 항등 행렬(Identity)로 초기화했을 때 더 나은 수렴과 최종 성능을 보였습니다.
-   **파인튜닝:** 컨텍스트 길이를 2048에서 4096으로 늘리고, 추가적으로 105억 토큰에 대해 파인튜닝을 진행했습니다.
-   **정규화:** 스칼라 게이팅을 사용한 그룹 정규화가 우수한 성능을 내는 데 중요한 요소임이 확인되었습니다.